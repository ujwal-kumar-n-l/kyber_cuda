%%writefile kyber_check_002.cu
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <cuda_runtime.h>

#define N 256
#define Q 3329
#define F 1441 
#define BATCH_SIZE 5

__device__ __constant__ int16_t d_zetas[128];
const int16_t h_zetas[128] = {
    -1044,-758,-359,-1517,1493,1422,287,202,-171,622,1577,182,962,-1202,-1474,1468,
    573,-1325,264,383,-829,1458,-1602,-130,-681,1017,732,608,-1542,411,-205,-1571,
    1223,652,-552,1015,-1293,1491,-282,-1544,516,-8,-320,-666,-1618,-1162,126,1469,
    -853,-90,-271,830,107,-1421,-247,-951,-398,961,-1508,-725,448,-1065,677,-1275,
    -1103,430,555,843,-1251,871,1550,105,422,587,177,-235,-291,-460,1574,1653,
    -246,778,1159,-147,-777,1483,-602,1119,-1590,644,-872,349,418,329,-156,-75,
    817,1097,603,610,1322,-1285,-1465,384,-1215,-136,1218,-1335,-874,220,-1187,-1659,
    -1185,-1530,-1278,794,-1510,-854,-870,478,-108,-308,996,991,958,-1460,1522,1628
};

// --- CPU REFERENCE LOGIC ---
int16_t cpu_fqmul(int16_t a, int16_t b) {
    int32_t r = (int32_t)a * b;
    r %= Q;
    if (r < 0) r += Q;
    return (int16_t)r;
}

void cpu_kyber_pipeline(int16_t *a, int16_t *b) {
    int k;
    // NTT
    k = 1;
    for (int len = 128; len >= 2; len >>= 1) {
        for (int start = 0; start < 256; start += 2 * len) {
            int16_t zeta = h_zetas[k++];
            for (int j = start; j < start + len; j++) {
                int16_t t = cpu_fqmul(zeta, a[j + len]);
                a[j + len] = (a[j] - t + Q) % Q;
                a[j] = (a[j] + t) % Q;
                t = cpu_fqmul(zeta, b[j + len]);
                b[j + len] = (b[j] - t + Q) % Q;
                b[j] = (b[j] + t) % Q;
            }
        }
    }
    // Mul
    for (int i = 0; i < 256; i++) a[i] = cpu_fqmul(a[i], b[i]);
    // INTT
    k = 127;
    for (int len = 2; len <= 128; len <<= 1) {
        for (int start = 0; start < 256; start += 2 * len) {
            int16_t zeta = h_zetas[k--];
            for (int j = start; j < start + len; j++) {
                int16_t u = a[j];
                a[j] = (u + a[j + len]) % Q;
                a[j + len] = cpu_fqmul(zeta, a[j + len] - u);
            }
        }
    }
    for (int i = 0; i < 256; i++) a[i] = cpu_fqmul(a[i], F);
}

// --- GPU KERNEL ---
__device__ __forceinline__ int16_t barrett_reduction(int32_t a) {
    int32_t v = ((int64_t)a * 20150) >> 26; 
    int32_t res = a - v * Q;
    if (res >= Q) res -= Q;
    if (res < 0) res += Q;
    return (int16_t)res;
}

__global__ void kyber_fused_kernel(int16_t *a_glob, int16_t *b_glob) {
    __shared__ int16_t A[256], B[256];
    int t = threadIdx.x; 
    int off = blockIdx.x * 256;

    A[t] = a_glob[off + t]; A[t+128] = a_glob[off + t+128];
    B[t] = b_glob[off + t]; B[t+128] = b_glob[off + t+128];
    __syncthreads();

    for (int len = 128; len >= 2; len >>= 1) {
        int start = (t / len) * (2 * len);
        int j = start + (t % len);
        int k = (128 / len) + (t / len); 
        int16_t zeta = d_zetas[k];
        int16_t ta = barrett_reduction((int32_t)zeta * A[j + len]);
        int16_t u_a = A[j];
        A[j] = (u_a + ta >= Q) ? u_a + ta - Q : u_a + ta;
        A[j + len] = (u_a - ta < 0) ? u_a - ta + Q : u_a - ta;
        int16_t tb = barrett_reduction((int32_t)zeta * B[j + len]);
        int16_t u_b = B[j];
        B[j] = (u_b + tb >= Q) ? u_b + tb - Q : u_b + tb;
        B[j + len] = (u_b - tb < 0) ? u_b - tb + Q : u_b - tb;
        __syncthreads();
    }

    A[t] = barrett_reduction((int32_t)A[t] * B[t]);
    A[t+128] = barrett_reduction((int32_t)A[t+128] * B[t+128]);
    __syncthreads();

    for (int len = 2; len <= 128; len <<= 1) {
        int start = (t / len) * (2 * len);
        int j = start + (t % len);
        int k = (256 / len) - 1 - (t / len);
        int16_t zeta = d_zetas[k];
        int16_t u = A[j];
        int32_t sum = u + A[j + len];
        A[j] = (sum >= Q) ? sum - Q : sum;
        A[j + len] = barrett_reduction((int32_t)zeta * (A[j + len] - u));
        __syncthreads();
    }

    a_glob[off + t] = barrett_reduction((int32_t)A[t] * F);
    a_glob[off + t + 128] = barrett_reduction((int32_t)A[t+128] * F);
}

int main() {
    size_t size = (size_t)BATCH_SIZE * N * sizeof(int16_t);
    int16_t *hA = (int16_t*)malloc(size);
    int16_t *hB = (int16_t*)malloc(size);
    int16_t *hRef = (int16_t*)malloc(size);

    for(int i=0; i < BATCH_SIZE * N; i++) {
        hA[i] = i % Q; hB[i] = (i * 3) % Q;
    }

    // --- CPU BENCHMARK ---
    int16_t *tempA = (int16_t*)malloc(size);
    int16_t *tempB = (int16_t*)malloc(size);
    memcpy(tempA, hA, size); memcpy(tempB, hB, size);

    struct timespec start_cpu, end_cpu;
    clock_gettime(CLOCK_MONOTONIC, &start_cpu);
    for(int b=0; b < BATCH_SIZE; b++) {
        cpu_kyber_pipeline(tempA + b*N, tempB + b*N);
    }
    clock_gettime(CLOCK_MONOTONIC, &end_cpu);
    memcpy(hRef, tempA, size);
    double cpu_time = (end_cpu.tv_sec - start_cpu.tv_sec) + (end_cpu.tv_nsec - start_cpu.tv_nsec) / 1e9;

    // --- GPU BENCHMARK ---
    int16_t *dA, *dB;
    cudaMalloc(&dA, size); cudaMalloc(&dB, size);
    cudaMemcpy(dA, hA, size, cudaMemcpyHostToDevice);
    cudaMemcpy(dB, hB, size, cudaMemcpyHostToDevice);
    cudaMemcpyToSymbol(d_zetas, h_zetas, sizeof(h_zetas));

    cudaEvent_t start_gpu, stop_gpu;
    cudaEventCreate(&start_gpu); cudaEventCreate(&stop_gpu);
    cudaEventRecord(start_gpu);
    kyber_fused_kernel<<<BATCH_SIZE, 128>>>(dA, dB);
    cudaEventRecord(stop_gpu);
    cudaEventSynchronize(stop_gpu);
    float ms_gpu = 0;
    cudaEventElapsedTime(&ms_gpu, start_gpu, stop_gpu);
    cudaMemcpy(hA, dA, size, cudaMemcpyDeviceToHost);

    // --- VALIDATION & COMPARISON ---
    int errs = 0;
    for(int i=0; i < BATCH_SIZE * N; i++) {
        if (hA[i] != hRef[i]) errs++;
    }

    printf("--- HI-Kyber Comparison Summary ---\n");
    printf("Validation: %s (%d errors)\n", (errs == 0 ? "SUCCESS (Matched)" : "FAILED"), errs);
    printf("Batch Size: %d Polynomials\n", BATCH_SIZE);
    printf("CPU Total Time: %.4f ms\n", cpu_time * 1000.0);
    printf("GPU Total Time: %.4f ms\n", ms_gpu);
    printf("GPU Average per Poly: %.4f us\n", (ms_gpu * 1000.0) / BATCH_SIZE);
    printf("Speedup Factor: %.2fx\n", (cpu_time * 1000.0) / ms_gpu);

    cudaFree(dA); cudaFree(dB); free(hA); free(hB); free(hRef); free(tempA); free(tempB);
    return 0;
}
